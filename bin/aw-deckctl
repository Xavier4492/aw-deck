#!/usr/bin/env bash
# aw-deckctl — petit utilitaire pour piloter l'état d'activité (client/projet/tache)
# Écrit un JSON dans ~/.local/state/aw-deck/state.json que aw-deckd lit périodiquement.
# Commandes principales :
#   - aw-deckctl start <client> [-p <projet>] [-t <tache>] : active la session et définit les champs
#   - aw-deckctl switch <client> [-p <projet>] [-t <tache>] : alias de start (changer de contexte)
#   - aw-deckctl stop : désactive la session (active:false)
#   - aw-deckctl status : affiche le JSON courant
#
# Exemples :
#   aw-deckctl start ACME -p SiteWeb -t "Fix header"
#   aw-deckctl switch ACME -p AppMobile
#   aw-deckctl stop
#
# Mapping typique dans StreamController :
#   - Bouton “ACME / SiteWeb”  =>  aw-deckctl start ACME -p SiteWeb
#   - Bouton “Pause/Stop”      =>  aw-deckctl stop
#   - Bouton “Switch tâche”    =>  aw-deckctl switch ACME -p SiteWeb -t "Bug #123"

set -euo pipefail

# --- Config Deck / retour Home ---
DECK="${DECK:-0}"
PAGE_HOME="${PAGE_HOME:-1}"
RETURN_HOME_ON_PROJECT="${RETURN_HOME_ON_PROJECT:-1}"

# Helper streamdeckc (n'échoue pas si absent / pas prêt)
sd() {
  if command -v streamdeckc >/dev/null 2>&1; then
    streamdeckc -d "$DECK" "$@" >/dev/null 2>&1
  else
    return 0
  fi
}

return_home() {
  # Retourne à la Home si activé
  if [ "${RETURN_HOME_ON_PROJECT}" = "1" ]; then
    sd -a SET_PAGE -p "$PAGE_HOME" || true
  fi
}

# Chemin du fichier d'état persistant dans XDG_STATE_HOME (fallback à ~/.local/state)
STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/aw-deck"
STATE="$STATE_DIR/state.json"
mkdir -p "$STATE_DIR"
[ -f "$STATE" ] || echo '{"active":false}' > "$STATE"

usage() {
  echo "Usage: aw-deckctl start <client> [-p <projet>] [-t <tache>] | switch <client> ... | stop | status"
  exit 1
}

# Écriture atomique du JSON (tmp dans le même répertoire + rename())
write_state() {
  local payload="$1"
  local tmp=""
  cleanup() { [ -n "${tmp:-}" ] && rm -f "$tmp"; }
  trap cleanup EXIT
  tmp="$(mktemp "$STATE_DIR/.state.json.XXXXXX")" || exit 1
  printf '%s\n' "$payload" > "$tmp"
  chmod 0644 "$tmp" 2>/dev/null || true   # optionnel : rendre lisible par d'autres
  mv -f "$tmp" "$STATE"                   # rename() atomique (même FS)
  tmp=""
  trap - EXIT
}

# Sous-commande (start|switch|stop|status)
cmd="${1:-}"; shift || true

case "$cmd" in
  start|switch)
    # On accepte start ou switch (switch = alias pratique pour changer de contexte)
    client=""; projet=""; tache=""
    # Parsing simple des options
    while [ $# -gt 0 ]; do
      case "$1" in
        -p|--projet) projet="${2:-}"; shift 2 ;;
        -t|--tache)  tache="${2:-}";  shift 2 ;;
        -*)
          echo "Option inconnue: $1"; usage ;;
        *)
          # Le premier argument non-option est <client>
          if [ -z "$client" ]; then
            client="$1"; shift
          else
            echo "Argument inconnu: $1"; exit 1
          fi
        ;;
      esac
    done

    # Client obligatoire
    [ -z "$client" ] && { echo "Client requis"; usage; }

    # Construire le JSON proprement
    payload="$(jq -nc --arg client "$client" --arg projet "$projet" --arg tache "$tache" '
      {active:true, client:$client}
      | if ($projet|length)>0 then .projet=$projet else . end
      | if ($tache|length)>0  then .tache=$tache  else . end
    ')"
    write_state "$payload"
    echo "Session ON: client=$client${projet:+, projet=$projet}${tache:+, tache=$tache}"

    return_home
  ;;

  stop)
    write_state "$(jq -nc '{active:false}')"
    echo "Session OFF"

    return_home
  ;;

  status)
    # Affiche l'état courant ; si absent => active:false
    if [ -f "$STATE" ]; then
      cat "$STATE"
    else
      echo '{"active":false}'
    fi
  ;;

  *)
    usage
  ;;
esac
